# Hibernate ORM 5.x 新特性

原文链接:http://www.cnblogs.com/qjjazry/p/6382073.html<br/>

1. 明确Hibernate是一个实现了ORM思想的框架，它封装了JDBC，是程序员可以用对象编程思想来操作数据库。

2. 明确ORM（对象关系映射）是一种思想，JPA（Java Persistence API）是JDK实现ORM思想的规范（一套接口），Hibernate又是这套接口的具体实现。

3. 明确Hibernate程序四要素：实体类（POJO类）、映射文件（*.hbm.xml）、主配置文件（hibernate.cfg.xml）和调用Hibernate的程序。

4. 明确映射文件中重点关注Hbiernate常用的六种内置主键生成策略：increment、identity、sequence、native、uuid、assigned生成策略。

5. 明确调用Hibernate程度时，session的方法必须在事务之内执行，因为session是操作缓存中的数据，只有提交了事务之后，缓存中的数据才能写到数据库中。

6. 明确Hibernate对单表的增删改查操作，注意查询的时候get与load的区别，注意底层增删改的执行顺序不一定同代码的顺序相同，如果想用一定的顺序执行，需要在适当的位置添加刷新点，以使刷新点之前的代码先执行。

 

7. 明确Hbiernate的四个重要接口：

　　1. Configuration接口：用于加载主配置文件和映射文件，以实现对Hibernate的启动。

　　2. SessionFactory接口：用于开启Session对象，SessionFactory是一个重量级对象（开销大）、单例对象，但同时是线程安全的（因为大多数成员变量是final的），由Configuration对象开启，应用结束时自动关闭。

　　3. Session接口：用于向应用程序提供操作数据库的方法，Session是一个轻量级对象、多例对象（一个用户一个Session对象）、线程不安全的（因为一个用户的多个事务会同时对Session对象进行访问，引起并发问题）；

　　Session的使用原则是一个线程（事务）一个Session，使用完毕，立即关闭；

　　因此，通常使用getCurrentSession()方法，它将openSession()方法包装到了ThreadLocal方法中，从而使得同一线程只有一个Session对象，且事务提交或回滚后，Session会自动关闭。

　　4. Transcation接口：通过该接口，可以将事务从持久层，提升到Dao层。由Session对象创建。

8. 明确Hibernate中的对象的四种状态：瞬时态、持久态、游离态、和无名态。

9. 明确Hibernate支持原始SQL语句查询，支持QBC查询及Hibernate特有的HQL查询。

　  HQL，Hibernate Query Language，Hibernate查询语言，它与SQL非常相似。但，HQL是面向对象的查询语言，而SQL是面向二维表的。HQL查询语句中使用的是类名与属性名，而SQL语句使用的是表名与字段名。
　  QBC，Query By Criteria，标准查询，一种比HQL更为面向对象的查询方法。

　注意：iterator()和list()方法的区别，以及N+1问题的解决。

 

10. 重点明确关联关系映射，关联关系在内存中反映为实体关系，映射到DB中为主外键关系。实体间的关联，即对外键的维护。关联关系的发生，即对外键数据的改变；

　　关联方向分为单向关联和双向关联；

　　关联关系维护，在1：n关联中分为一方维护和多方维护，两者的底层执行是不同的，哪方维护关联关系，代码中就save谁，并且执行时先插入关联方数据，另外只有一方可以放弃维护权，转交给多方维护；

　　关联关系维护，在n：m关联中是通过中间表的形式实现的。

 

11. 明确Hbiernate检索优化，所谓检索优化，指的是并不是代码中一出现查询语句，马上就在后台调用执行select语句。而是在代码中真正需要时才执行select。即将select的执行进行了最大可能的“延迟”；

　　根据检索对象的不同，可以将检索优化分为两类：  （1）当前对象检索优化 （2）关联对象检索优化

　　对于不使用优化进行对象检索的过程，称为直接加载；否则称为延迟加载，或懒加载。

　　对于当前对象进行检索加载，Session中提供了两个方法：get()与load()；

　　默认情况下，get()为直接加载，而load()为延迟加载，load()方法默认情况下采用延迟加载策略，但也是可以改变的，可以改为直接加载；

　　对于关联对象的检索，也可进行延迟加载的优化。采用何种优化策略，要依据映射文件的配置。映射文件中对于关联对象检索的优化配置属性有两个：lazy、fetch；

　　关联对象检索优化分为两种：  （1）多端配置优化  （2）单端配置优化 

 

12. 明确Hibernate缓存机制，分为事务范围缓存、应用范围缓存、集群范围缓存（不介绍）

　　1. 事务范围缓存（单Session，即一级缓存）：伴随着事务的开启而开启，伴随着事务的关闭而关闭，一级缓存由Hibernate管理，不受程序员控制；

　 　注意刷新时间点的概念，Session的刷新是指Session缓存中的数据的更新，默认的刷新时间点有三个：执行Query查询，执行session.flush()，执行事务的提交，可以修改刷新时间点，是部分时间点失效；

　　插入操作不到刷新时间点就执行，删除操作一到刷新时间点就执行，更新操作到刷新时间点要比较快照才能决定是否执行；

　　注意同步时间点的概念，Session的同步是指，将Session缓存中的数据同步更新到数据库中，执行同步的时间点只有一个：事务的提交；

　　注意快照的概念，简单来说就是当代码通过Session的查询方法调用，将数据加载到内存后，Hbiernate会将此数据存于Session缓存中，同时在快照中备份该数据，快照中的数据在刷新点前是不可以被修改的，当刷新点到来时，比较快照中的数据和Session缓存中的数据，无论是否执行update语句，只有数据不相同的时候，才执行相应的更新操作，同时改变Session缓存中的数据和快照中的数据。

　　2. 应用范围缓存（单SessionFactory，即二级缓存）：应用范围的缓存可以被应用程序内的所有事务共享访问，缓存的生命周期依赖于应用的生命周期；

　　准确来说，SessionFactory缓存的外置缓存才称作二级缓存，Hbiernate本身只提供了二级缓存的规范，但没有实现，所以需要提供第三方缓存产品的支持；

　　二级缓存分为四类：类缓存、集合缓存、更新时间戳缓存、查询缓存（Query查询结果的缓存，区分于get和load方法）,一级缓存只有类缓存；

　　类缓存，缓存的是类的详情；集合缓存，在没有对集合中元素对应的类进行类缓存的时候，缓存的是所有元素的id；

　　Query查询默认不会从一、二级缓存中读取数据，但可以改变，同时Query查询要从缓存中读取数据，必须保证Query所执行的HQL语句完全相同；

　　二级缓存的并发访问策略（具体现在不研究）：事务型、读写型、非严格读写型、只读型；

 

13. 明确Hibernate对事务并发控制的管理，使用乐观锁和悲观锁解决提交更新丢失问题，同时Hbiernate可以设置事务的隔离级别，同数据库的事务隔离级别。

14. 明确Hibernate注解开发，主要是为了替代映射文件。